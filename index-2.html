<!DOCTYPE html>
<html>
<head>
  <title>Teachable Machine + MQTT (แยกผัก + MQTT)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.4/dist/teachablemachine-image.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
  <style>
    body {
      font-family: "Segoe UI", Arial, sans-serif;
      margin: 0; padding: 0;
      background: linear-gradient(135deg, #e0f7fa, #ffffff);
      color: #333;
      text-align: center;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
    }

    h2 {
      margin: 20px 0;
      font-size: 1.8em;
      letter-spacing: 1px;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
    }

    button {
      padding: 12px 25px;
      margin: 8px;
      font-size: 1em;
      font-weight: bold;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: 0.3s;
      color: white;
      background: linear-gradient(135deg, #2196f3, #0d47a1); /* ฟ้า–น้ำเงิน */
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    }
    button:hover {
      opacity: 0.9;
      transform: scale(1.05);
    }

    #status {
      margin: 15px;
      padding: 12px 20px;
      border-radius: 10px;
      font-size: 1.1em;
      font-weight: bold;
      background: rgba(255,255,255,0.15);
      backdrop-filter: blur(5px);
    }
    .error { background: rgba(33, 150, 243, 0.7); }
    .success { background: rgba(13, 71, 161, 0.7); }

    #webcam-container {
      margin: 15px auto;
      padding: 10px;
      background: rgba(255,255,255,0.1);
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      max-width: 640px;
    }
    #webcam-container canvas {
      width: 100%; border-radius: 12px;
    }

    #label-container {
      margin-top: 15px;
      font-size: 1.2em;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }
    #label-container div {
      background: rgba(255,255,255,0.2);
      padding: 8px 15px;
      border-radius: 10px;
      width: 80%;
      max-width: 400px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body style="text-align:center; font-family:sans-serif;">
  <h2>แยกผัก + MQTT</h2>
  <div>
    <button onclick="init('environment')">Start (Back Camera)</button>
    <button onclick="init('user')">Start (Front Camera)</button>
    <button onclick="stop()">Stop</button>
  </div>

  <div id="status" class="status">Preparing...</div>
  <div id="webcam-container"></div>
  <div id="label-container"></div>

  <script type="text/javascript">
    const URL = "https://teachablemachine.withgoogle.com/models/d89GuuawT/";
    const MQTT_TOPIC = "ttky";

    let model, webcam, labelContainer, maxPredictions;
    let mqttClient;
    let sending = false;
    let paused = false;
    let timeoutId;
    let isRunning = false;

    function updateStatus(message, type = "status") {
      const statusDiv = document.getElementById("status");
      statusDiv.innerText = message;
      statusDiv.className = `status ${type}`;
    }

    function connectMQTT() {
      return new Promise((resolve, reject) => {
        try {
          const clientId = "clientId-GMyVYMltV6" + Math.floor(Math.random() * 10000);
          mqttClient = new Paho.MQTT.Client("broker.hivemq.com", 8884, "/mqtt", clientId);

          mqttClient.onConnectionLost = (responseObject) => {
            console.error("MQTT lost:", responseObject.errorMessage);
            updateStatus("MQTT lost. Reconnecting...", "error");
            if (isRunning) {
              setTimeout(() => connectMQTT().catch(() => {}), 5000);
            }
          };

          mqttClient.connect({
            useSSL: true,
            timeout: 30,
            keepAliveInterval: 60,
            cleanSession: true,
            onSuccess: () => {
              console.log("MQTT connected");
              updateStatus("MQTT connected", "success");
              resolve();
            },
            onFailure: (e) => {
              console.error("MQTT failed:", e.errorMessage);
              updateStatus("MQTT connecting failed: " + e.errorMessage, "error");
              reject(e);
            }
          });
        } catch (error) {
          console.error("MQTT setup error:", error);
          updateStatus("MQTT setup error: " + (error?.message || JSON.stringify(error)), "error");
          reject(error);
        }
      });
    }

    async function init(facingMode) {
      try {
        isRunning = true;
        updateStatus("connecting MQTT...");
        await connectMQTT();

        updateStatus("downloading model...");
        const modelURL = URL + "model.json";
        const metadataURL = URL + "metadata.json";
        model = await tmImage.load(modelURL, metadataURL);
        maxPredictions = model.getTotalClasses();
        updateStatus("load model successful", "success");

        updateStatus("opening camera...");
        webcam = new tmImage.Webcam(320, 240, false);
        try {
          await webcam.setup({ facingMode: facingMode || "environment" });
          await webcam.play();
        } catch (error) {
          if (error.name === "NotAllowedError") {
            updateStatus("please give permission to acess camera ", "error");
          } else if (error.name === "NotFoundError") {
            updateStatus("camera not found", "error");
          } else {
            updateStatus("can't open camera: " + (error?.message || JSON.stringify(error)), "error");
          }
          throw error;
        }
        document.getElementById("webcam-container").innerHTML = '';
        document.getElementById("webcam-container").appendChild(webcam.canvas);

        labelContainer = document.getElementById("label-container");
        labelContainer.innerHTML = "";
        for (let i = 0; i < maxPredictions; i++) {
          labelContainer.appendChild(document.createElement("div"));
        }

        updateStatus("camera is on - detecting...", "success");
        window.requestAnimationFrame(loop);

      } catch (error) {
        console.error("Init error:", error);
        updateStatus("Error: " + (error?.message || JSON.stringify(error)), "error");
        isRunning = false;
      }
    }

    async function loop() {
      if (!paused && isRunning && webcam) {
        try {
          webcam.update();
          await predict();
        } catch (error) {
          updateStatus("Prediction error: " + (error?.message || JSON.stringify(error)), "error");
        }
      }
      if (isRunning) {
        setTimeout(() => window.requestAnimationFrame(loop), 100);
      }
    }

    async function predict() {
      const prediction = await model.predict(webcam.canvas);

      for (let i = 0; i < maxPredictions; i++) {
        const prob = prediction[i].probability;
        const className = prediction[i].className;
        const text = `${className}: ${prob.toFixed(2)}`;
        if (labelContainer.childNodes[i]) labelContainer.childNodes[i].innerText = text;

        if (prob >= 0.9 && !sending) {
          sending = true;
          paused = true;
          updateStatus(`found ${className} - sending...`, "success");

          if (timeoutId) clearTimeout(timeoutId);
          timeoutId = setTimeout(() => {
            try {
              if (mqttClient && mqttClient.isConnected()) {
                const message = new Paho.MQTT.Message(className);
                message.destinationName = MQTT_TOPIC;
                mqttClient.send(message);
                updateStatus(`ส่งแล้ว: ${className}`, "success");
              } else {
                updateStatus("MQTT ไม่ได้เชื่อมต่อ", "error");
              }
            } catch (error) {
              updateStatus("ส่ง MQTT ล้มเหลว: " + (error?.message || JSON.stringify(error)), "error");
            } finally {
              sending = false;
              paused = false;
              setTimeout(() => {
                if (isRunning) updateStatus("กำลังตรวจจับ...", "success");
              }, 1000);
            }
          }, 3000);
          break;
        }
      }
    }

    function stop() {
      isRunning = false;
      paused = false;
      sending = false;
      if (timeoutId) clearTimeout(timeoutId);

      if (webcam) {
        try { webcam.stop(); } catch (e) {}
        webcam = null;
      }

      document.getElementById("webcam-container").innerHTML = '';
      document.getElementById("label-container").innerHTML = '';

      if (mqttClient && mqttClient.isConnected()) {
        try { mqttClient.disconnect(); } catch (e) {}
        mqttClient = null;
      }

      updateStatus("The process has been stopped", "status");
    }

    window.addEventListener('beforeunload', stop);
  </script>
</body>
</html>



